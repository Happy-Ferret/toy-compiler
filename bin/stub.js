(function() { "use strict"; 
let errors = [];let __imports = {error: function (msg) { console.error('Error: '+msg);errors.push(msg); } , readFile: function (path) { return (require('fs').readFileSync('src/'+path, 'utf-8')); } , getPlatformName: function () { return (require('os').platform()); }  };let Scope = (function () { function Scope() { this.node = null;this.parent = null;this.symbols = { };this.isGlobal = false; }; Scope.prototype.resolve = function (id) { if (this.symbols[id]) { return (this.symbols[id]); } else  { if (this.parent) { return (this.parent.resolve(id)); } ; } ;return (null); } ;Scope.prototype.register = function (id, node) { this.symbols[id]=node; } ;return (Scope); })() ;;let idx = 1;const TT_UNKNOWN = idx++;const KK_LET = idx++;const KK_CONST = idx++;const KK_CLASS = idx++;const KK_EXPORT = idx++;const KK_FUNCTION = idx++;const KK_IF = idx++;const KK_ELSE = idx++;const KK_WHILE = idx++;const KK_BREAK = idx++;const KK_CONTINUE = idx++;const KK_RETURN = idx++;const KK_INCLUDE = idx++;const PP_LPAREN = idx++;const PP_RPAREN = idx++;const PP_LBRACK = idx++;const PP_RBRACK = idx++;const PP_LBRACE = idx++;const PP_RBRACE = idx++;const PP_DOT = idx++;const PP_COLON = idx++;const PP_COMMA = idx++;const PP_SEMIC = idx++;const OP_ASS = idx++;const OP_ADD = idx++;const OP_SUB = idx++;const OP_MUL = idx++;const OP_DIV = idx++;const OP_OR = idx++;const OP_AND = idx++;const OP_NOT = idx++;const OP_LT = idx++;const OP_LTE = idx++;const OP_GT = idx++;const OP_GTE = idx++;const OP_EQUAL = idx++;const OP_NEQUAL = idx++;const OP_BIN_OR = idx++;const OP_BIN_AND = idx++;const OP_ADD_ADD = idx++;const OP_SUB_SUB = idx++;const OP_NEW = idx++;const TT_NULL = idx++;const TT_STRING = idx++;const TT_NUMBER = idx++;const TT_BOOLEAN = idx++;const TT_IDENTIFIER = idx++;const NN_UNKNOWN = idx++;const NN_PROGRAM = idx++;const NN_IGNORE = idx++;const NN_INCLUDE = idx++;const NN_EXPORT = idx++;const NN_NEW = idx++;const NN_IF = idx++;const NN_LET = idx++;const NN_CONST = idx++;const NN_CLASS = idx++;const NN_CLASS_METHOD = idx++;const NN_CLASS_PROPERTY = idx++;const NN_CLASS_CONSTRUCTOR = idx++;const NN_FUNCTION = idx++;const NN_UNARY_PREFIX_EXPRESSION = idx++;const NN_UNARY_POSTFIX_EXPRESSION = idx++;const NN_BINARY_EXPRESSION = idx++;const NN_MEMBER_EXPRESSION = idx++;const NN_COMPUTED_MEMBER_EXPRESSION = idx++;const NN_OBJECT_EXPRESSION = idx++;const NN_OBJECT_PROPERTY = idx++;const NN_ARRAY_EXPRESSION = idx++;const NN_ARRAY_ELEMENT = idx++;const NN_CALL_EXPRESSION = idx++;const NN_WHILE = idx++;const NN_RETURN = idx++;const NN_BREAK = idx++;const NN_CONTINUE = idx++;const NN_LITERAL = idx++;const NN_STRING_LITERAL = idx++;function processToken(tokens, value, line, column) { let kind = TT_UNKNOWN;if (value === 'let') { kind=KK_LET; } else if (value === 'const') { kind=KK_CONST; } else if (value === 'class') { kind=KK_CLASS; } else if (value === 'export') { kind=KK_EXPORT; } else if (value === 'function') { kind=KK_FUNCTION; } else if (value === 'if') { kind=KK_IF; } else if (value === 'else') { kind=KK_ELSE; } else if (value === 'while') { kind=KK_WHILE; } else if (value === 'break') { kind=KK_BREAK; } else if (value === 'continue') { kind=KK_CONTINUE; } else if (value === 'return') { kind=KK_RETURN; } else if (value === '#include') { kind=KK_INCLUDE; } else if (value === 'true'||value === 'false') { kind=TT_BOOLEAN; } else if (value === 'null') { kind=TT_NULL; } else if (value === '(') { kind=PP_LPAREN; } else if (value === ')') { kind=PP_RPAREN; } else if (value === '[') { kind=PP_LBRACK; } else if (value === ']') { kind=PP_RBRACK; } else if (value === '{') { kind=PP_LBRACE; } else if (value === '}') { kind=PP_RBRACE; } else if (value === '.') { kind=PP_DOT; } else if (value === ':') { kind=PP_COLON; } else if (value === ',') { kind=PP_COMMA; } else if (value === ';') { kind=PP_SEMIC; } else if (value === '!') { kind=OP_NOT; } else if (value === '=') { kind=OP_ASS; } else if (value === '+') { kind=OP_ADD; } else if (value === '-') { kind=OP_SUB; } else if (value === '*') { kind=OP_MUL; } else if (value === '/') { kind=OP_DIV; } else if (value === '<') { kind=OP_LT; } else if (value === '<=') { kind=OP_LTE; } else if (value === '>') { kind=OP_GT; } else if (value === '>=') { kind=OP_GTE; } else if (value === '|') { kind=OP_BIN_OR; } else if (value === '&') { kind=OP_BIN_AND; } else if (value === '==') { kind=OP_EQUAL; } else if (value === '!=') { kind=OP_NEQUAL; } else if (value === '||') { kind=OP_OR; } else if (value === '&&') { kind=OP_AND; } else if (value === '++') { kind=OP_ADD_ADD; } else if (value === '--') { kind=OP_SUB_SUB; } else if (value === 'new') { kind=OP_NEW; } else  { kind=TT_IDENTIFIER; } ;let token = createToken(kind, value, line, column-value.length);tokens.push(token);return (token); } ;function createToken(kind, value, line, column) { let token = {kind: kind, value: value, line: line, column: column };return (token); } ;;let Node = (function () { function Node(kind) { this.kind=kind; } return (Node); })() ;let node = new Node(NN_FUNCTION);;let Scanner = (function () { function Scanner() { this.ii = 0;this.line = 0;this.column = 0; }; Scanner.prototype.next = function () { this.ii++;this.column++; } ;Scanner.prototype.isBlank = function (cc) { return (cc === 9||cc === 11||cc === 12||cc === 32||cc === 160); } ;Scanner.prototype.isQuote = function (cc) { return (cc === 39||cc === 34); } ;Scanner.prototype.isAlpha = function (cc) { return (cc>=65&&cc<=90||cc>=97&&cc<=122||cc === 95||cc === 35); } ;Scanner.prototype.isNumber = function (cc) { return (cc>=48&&cc<=57); } ;Scanner.prototype.scan = function (str) { this.ii=-1;this.line=1;this.column=0;let tokens = [];let length = str.length;while (true) {this.next();let ch = str.charAt(this.ii);let cc = str.charCodeAt(this.ii);if (this.isBlank(cc)) { continue; } ;if (cc === 10) { this.line++;this.column=0;continue; } ;if (this.isAlpha(cc)) { let start = this.ii;while (true) {if (!this.isAlpha(cc)) { this.ii--;this.column--;break; } ;this.next();cc=str.charCodeAt(this.ii); } ;let content = str.slice(start, this.ii+1);processToken(tokens, content, this.line, this.column);continue; } ;if (this.isNumber(cc)||cc === 45&&this.isNumber(str.charCodeAt(this.ii+1))) { let start = this.ii;while (true) {if (!this.isNumber(cc)&&cc !== 45) { this.ii--;this.column--;break; } ;this.next();cc=str.charCodeAt(this.ii); } ;let content = str.slice(start, this.ii+1);let token = createToken(TT_NUMBER, content, this.line, this.column);tokens.push(token);continue; } ;if (this.isQuote(cc)) { let start = this.ii;let begin = cc;while (true) {this.next();cc=str.charCodeAt(this.ii);if (this.isQuote(cc)&&cc === begin) { break; } ; } ;let content = str.slice(start+1, this.ii);let token = createToken(TT_STRING, content, this.line, this.column);token.isChar=content[0] === "'";tokens.push(token);continue; } ;if (ch === '/') { if (str.charAt(this.ii+1) === '/') { while (true) {if (cc === 10) { this.column=0;this.line++;break; } ;this.next();cc=str.charCodeAt(this.ii); } ; } else if (str.charAt(this.ii+1) === '*') { while (true) {if (cc === 10) { this.column=0;this.line++; } else if (cc === 42) { if (str.charCodeAt(this.ii+1) === 47) { break; } ; } ;this.next();cc=str.charCodeAt(this.ii); } ; } ;continue; } ;if (ch === '('||ch === ')'||ch === '['||ch === ']'||ch === '{'||ch === '}'||ch === '.'||ch === ':'||ch === ','||ch === ';'||ch === '*'||ch === '/') { let content = str.slice(this.ii, this.ii+1);processToken(tokens, content, this.line, this.column);continue; } ;if (ch === '+'||ch === '-'||ch === '!'||ch === '='||ch === '|'||ch === '&'||ch === '>'||ch === '<') { let second = str.slice(this.ii+1, this.ii+2);if (ch === '+') { if (ch+second === '++') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '-') { if (ch+second === '--') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '!') { if (ch+second === '!=') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '=') { if (ch+second === '==') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '|') { if (ch+second === '||') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '|') { if (ch+second === '||') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '&') { if (ch+second === '&&') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '>') { if (ch+second === '>=') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } else if (ch === '<') { if (ch+second === '<=') { this.next();processToken(tokens, ch+second, this.line, this.column); } else  { processToken(tokens, ch, this.line, this.column); } ; } ;continue; } ;if (this.ii>=length) { break; } ; } ;return (tokens); } ;return (Scanner); })() ;;let Parser = (function () { function Parser() { this.pindex = 0;this.scope = null;this.tokens = null;this.current = null; }; Parser.prototype.createNode = function (kind) { let node = new Node(kind);return (node); } ;Parser.prototype.include = function (path) { let str = __imports.readFile(path);let scanner = new Scanner();let tokens = scanner.scan(str);let parser = new Parser();let ast = parser.parse(tokens);let generator = new Generator();let code = generator.generate(ast);return (code); } ;Parser.prototype.isBinaryOperator = function (token) { let kind = token.kind;return (kind === OP_ASS||kind === OP_ADD||kind === OP_SUB||kind === OP_MUL||kind === OP_DIV||kind === OP_OR||kind === OP_AND||kind === OP_NOT||kind === OP_LT||kind === OP_LTE||kind === OP_GT||kind === OP_GTE||kind === OP_EQUAL||kind === OP_NEQUAL||kind === OP_BIN_OR||kind === OP_BIN_AND&&!this.isUnaryPrefixOperator(token)); } ;Parser.prototype.isUnaryPrefixOperator = function (token) { let kind = token.kind;return (kind === OP_NEW||kind === OP_NOT||kind === OP_ADD_ADD||kind === OP_SUB_SUB); } ;Parser.prototype.isUnaryPostfixOperator = function (token) { let kind = token.kind;return (kind === OP_ADD_ADD||kind === OP_SUB_SUB); } ;Parser.prototype.isLiteral = function (token) { let kind = token.kind;return (kind === TT_NULL||kind === TT_STRING||kind === TT_NUMBER||kind === TT_BOOLEAN||kind === TT_IDENTIFIER); } ;Parser.prototype.parse = function (tokens) { let node = {kind: NN_PROGRAM, body: null };this.tokens=tokens;this.pindex=-1;this.next();this.pushScope(node);this.scope.parent=null;this.scope.isGlobal=true;node.body=this.parseStatementList();this.popScope();return (node); } ;Parser.prototype.pushScope = function (node) { let scp = new Scope();scp.node=node;scp.parent=this.scope;node.context=scp;this.scope=scp; } ;Parser.prototype.popScope = function () { if (this.scope !== null) { this.scope=this.scope.parent; } ; } ;Parser.prototype.parseStatementList = function () { let list = [];while (true) {if (!this.current) { break; } ;if (this.peek(PP_RBRACE)) { break; } ;let node = this.parseStatement();if (!node) { break; } ;if (node.kind !== NN_IGNORE) { list.push(node); } ; } ;return (list); } ;Parser.prototype.parseStatement = function () { let node = null;if (this.peek(KK_LET)) { node=this.parseVariableDeclaration(NN_LET); } else if (this.peek(KK_CONST)) { node=this.parseVariableDeclaration(NN_CONST); } else if (this.peek(KK_CLASS)) { node=this.parseClassDeclaration(); } else if (this.peek(KK_EXPORT)) { node=this.parseExportDeclaration(); } else if (this.peek(KK_FUNCTION)) { node=this.parseFunctionDeclaration(true); } else if (this.peek(KK_RETURN)) { node=this.parseReturnStatement(); } else if (this.peek(KK_IF)) { node=this.parseIfStatement(); } else if (this.peek(KK_WHILE)) { node=this.parseWhileStatement(); } else if (this.peek(KK_INCLUDE)) { this.next();let code = this.include(this.current.value);node={kind: NN_INCLUDE, code: code };this.next(); } else  { node=this.parseExpression();if (node === null) { let current = this.current;__imports.error('Unknown node kind '+current.value+' in '+current.line+':'+current.column); } ; } ;this.eat(PP_SEMIC);return (node); } ;Parser.prototype.parseExportDeclaration = function () { this.expect(KK_EXPORT);let node = {kind: NN_EXPORT, node: this.parseStatement() };node.node.isExported=true;return (node); } ;Parser.prototype.parseClassDeclaration = function () { this.expect(KK_CLASS);let node = {kind: NN_CLASS, id: this.current.value, ctor: null, body: null };this.expect(TT_IDENTIFIER);this.scope.register(node.id, node);this.expect(PP_LBRACE);this.pushScope(node);node.body=this.parseClassBody(node);this.popScope();this.expect(PP_RBRACE);return (node); } ;Parser.prototype.parseClassBody = function (parent) { let list = [];while (true) {if (!this.current) { break; } ;if (this.peek(PP_RBRACE)) { break; } ;let node = this.parseClassBodyItem();this.eat(PP_SEMIC);if (!node) { break; } ;if (node.kind === NN_CLASS_CONSTRUCTOR) { parent.ctor=node; } ;list.push(node); } ;return (list); } ;Parser.prototype.parseClassBodyItem = function () { let id = this.current.value;let node = null;this.expect(TT_IDENTIFIER);if (this.peek(PP_LPAREN)) { let kind = null;if (id === 'constructor') { kind=NN_CLASS_CONSTRUCTOR; } else  { kind=NN_CLASS_METHOD; } ;node={id: id, kind: kind, init: null };this.scope.register(node.id, node);this.pushScope(node);node.init=this.parseFunctionDeclaration(false);this.popScope(); } else if (this.eat(PP_COLON)) { node={id: id, kind: NN_CLASS_PROPERTY, init: this.parseExpression() };this.scope.register(node.id, node); } else  { __imports.error('Unexpected class token '+this.current.value); } ;return (node); } ;Parser.prototype.parseWhileStatement = function () { let node = {kind: NN_WHILE, condition: null, body: null };this.expect(KK_WHILE);node.condition=this.parseExpression();this.pushScope(node);if (this.eat(PP_LBRACE)) { node.body=this.parseStatementList();this.expect(PP_RBRACE); } else  { node.body=this.parseExpression(); } ;this.popScope();return (node); } ;Parser.prototype.parseIfStatement = function () { let node = {kind: NN_IF, condition: null, alternate: null, consequent: null };if (!this.eat(KK_IF)) { this.pushScope(node);node.consequent=this.parseIfBody();this.popScope();return (node); } ;this.expect(PP_LPAREN);node.condition=this.parseExpression();this.expect(PP_RPAREN);this.pushScope(node);node.consequent=this.parseIfBody();this.popScope();if (this.eat(KK_ELSE)) { node.alternate=this.parseIfStatement(); } ;return (node); } ;Parser.prototype.parseIfBody = function () { let node = null;if (this.eat(PP_LBRACE)) { node=this.parseStatementList();this.expect(PP_RBRACE); } else  { node=[this.parseExpression()];this.eat(PP_SEMIC); } ;return (node); } ;Parser.prototype.parseReturnStatement = function () { this.expect(KK_RETURN);let node = {kind: NN_RETURN, argument: this.parseExpression() };return (node); } ;Parser.prototype.parseFunctionDeclaration = function (strict) { if (strict) { this.expect(KK_FUNCTION); } ;let node = {kind: NN_FUNCTION, id: null, parameter: null, body: null };if (this.peek(TT_IDENTIFIER)) { node.id=this.current.value;this.scope.register(node.id, node);this.next(); } ;node.parameter=this.parseFunctionParameters();this.pushScope(node);if (this.eat(PP_LBRACE)) { node.body=this.parseStatementList();this.expect(PP_RBRACE); } ;this.popScope();return (node); } ;Parser.prototype.parseFunctionParameters = function () { let params = [];this.expect(PP_LPAREN);while (true) {if (this.peek(PP_RPAREN)) { break; } ;params.push(this.current);this.next();if (!this.eat(PP_COMMA)) { break; } ; } ;this.expect(PP_RPAREN);return (params); } ;Parser.prototype.parseVariableDeclaration = function (kind) { this.next();this.expectIdentifier();let node = {kind: kind, id: this.current.value, init: null };this.next();this.scope.register(node.id, node);this.expect(OP_ASS);node.init=this.parseExpression();return (node); } ;Parser.prototype.parseMemberExpression = function (parent) { this.expect(PP_DOT);let node = {kind: NN_MEMBER_EXPRESSION, parent: parent, member: this.parseExpression() };return (node); } ;Parser.prototype.parseComputedMemberExpression = function (parent) { this.expect(PP_LBRACK);let node = {kind: NN_COMPUTED_MEMBER_EXPRESSION, parent: parent, member: this.parseExpression() };this.expect(PP_RBRACK);return (node); } ;Parser.prototype.parseCallExpression = function (id) { let node = {kind: NN_CALL_EXPRESSION, callee: id, parameter: this.parseCallParameters() };return (node); } ;Parser.prototype.parseCallParameters = function () { let params = [];this.expect(PP_LPAREN);while (true) {if (this.peek(PP_RPAREN)) { break; } ;let expr = this.parseExpression();params.push(expr);if (!this.eat(PP_COMMA)) { break; } ; } ;this.expect(PP_RPAREN);return (params); } ;Parser.prototype.parseBreak = function () { this.expect(KK_BREAK);let node = {kind: NN_BREAK };return (node); } ;Parser.prototype.parseContinue = function () { this.expect(KK_CONTINUE);let node = {kind: NN_CONTINUE };return (node); } ;Parser.prototype.parseObjectExpression = function () { let node = {kind: NN_OBJECT_EXPRESSION, properties: [] };this.expect(PP_LBRACE);while (true) {if (this.peek(PP_RBRACE)) { break; } ;let property = {kind: NN_OBJECT_PROPERTY, id: this.parseLiteral(), value: null };this.expect(PP_COLON);property.value=this.parseStatement();node.properties.push(property);if (!this.eat(PP_COMMA)) { break; } ; } ;this.expect(PP_RBRACE);return (node); } ;Parser.prototype.parseArrayExpression = function () { this.expect(PP_LBRACK);let node = {kind: NN_ARRAY_EXPRESSION, elements: [] };while (true) {if (this.peek(PP_RBRACK)) { break; } ;let element = {kind: NN_ARRAY_ELEMENT, value: this.parseExpression() };node.elements.push(element);if (!this.eat(PP_COMMA)) { break; } ; } ;this.expect(PP_RBRACK);return (node); } ;Parser.prototype.parseUnaryPrefixExpression = function () { let node = {kind: NN_UNARY_PREFIX_EXPRESSION, operator: this.current.value, value: null };this.next();node.value=this.parseExpression();return (node); } ;Parser.prototype.parseUnaryPostfixExpression = function (left) { let node = {kind: NN_UNARY_POSTFIX_EXPRESSION, operator: this.current.value, value: left };this.next();return (node); } ;Parser.prototype.parseBinaryExpression = function (left) { let node = {kind: NN_BINARY_EXPRESSION, left: left, right: null, operator: this.current.value };this.next();node.right=this.parseExpression();return (node); } ;Parser.prototype.parseInfix = function (left) { if (this.isBinaryOperator(this.current)) { return (this.parseBinaryExpression(left)); } ;if (this.isUnaryPostfixOperator(this.current)) { return (this.parseUnaryPostfixExpression(left)); } ;if (this.peek(PP_LPAREN)) { return (this.parseCallExpression(left)); } ;if (this.peek(PP_DOT)) { return (this.parseMemberExpression(left)); } ;if (this.peek(PP_LBRACK)) { return (this.parseComputedMemberExpression(left)); } ;return (left); } ;Parser.prototype.parsePrefix = function () { if (this.isLiteral(this.current)) { return (this.parseLiteral()); } ;if (this.peek(PP_LBRACE)) { return (this.parseObjectExpression()); } ;if (this.peek(PP_LBRACK)) { return (this.parseArrayExpression()); } ;if (this.eat(PP_LPAREN)) { let node = this.parseExpression();this.expect(PP_RPAREN);return (node); } ;if (this.isUnaryPrefixOperator(this.current)) { return (this.parseUnaryPrefixExpression()); } ;return (this.parseStatement()); } ;Parser.prototype.parseExpression = function () { if (this.peek(KK_BREAK)) { return (this.parseBreak()); } ;if (this.peek(KK_CONTINUE)) { return (this.parseContinue()); } ;let node = this.parsePrefix();while (true) {if (!this.current) { break; } ;let expr = this.parseInfix(node);if (expr === null||expr === node) { break; } ;node=expr; } ;return (node); } ;Parser.prototype.parseLiteral = function () { if (this.peek(TT_STRING)) { return (this.parseStringLiteral()); } ;let current = this.current;let node = {kind: NN_LITERAL, type: current.kind, value: current.value };this.next();return (node); } ;Parser.prototype.parseStringLiteral = function () { let current = this.current;let node = {kind: NN_STRING_LITERAL, type: current.kind, value: current.value, isChar: current.isChar };this.next();return (node); } ;Parser.prototype.expectIdentifier = function () { let current = this.current;if (current.kind !== TT_IDENTIFIER) { __imports.error('Expected '+TT_IDENTIFIER+':identifier but got '+current.kind+':'+current.value); } ; } ;Parser.prototype.peek = function (kind) { return (this.current&&this.current.kind === kind); } ;Parser.prototype.next = function () { this.pindex++;this.current=this.tokens[this.pindex]; } ;Parser.prototype.back = function () { this.pindex=this.pindex-2;this.next(); } ;Parser.prototype.expect = function (kind) { let current = this.current;if (current.kind !== kind) { __imports.error('Expected '+kind+' but got '+current.kind+' in '+current.line+':'+current.column); } else  { this.next(); } ; } ;Parser.prototype.eat = function (kind) { if (this.peek(kind)) { this.next();return (true); } ;return (false); } ;return (Parser); })() ;;let Generator = (function () { function Generator() { this.out = ''; }; Generator.prototype.write = function (str) { this.out=this.out+str; } ;Generator.prototype.generate = function (node) { this.generateBody(node.body);return (this.out); } ;Generator.prototype.generateBody = function (body) { let ii = 0;while (ii<body.length) {this.generateNode(body[ii]);ii++;this.write(';'); } ; } ;Generator.prototype.generateArguments = function (args) { this.write('(');let ii = 0;while (ii<args.length) {this.write(args[ii].value);if (ii+1<args.length) { this.write(', '); } ;ii++; } ;this.write(')'); } ;Generator.prototype.generateNodesOfBody = function (body, kind) { let ii = 0;while (ii<body.length) {if (body[ii].kind === kind) { this.generateNode(body[ii]);this.write(';'); } ;ii++; } ; } ;Generator.prototype.generateNode = function (node) { let kind = node.kind;if (kind === NN_CLASS_PROPERTY) { this.write('this.');this.write(node.id);this.write(' = ');this.generateNode(node.init); } else if (kind === NN_CLASS_METHOD||kind === NN_CLASS_CONSTRUCTOR) { this.write(node.context.parent.node.id);this.write('.prototype.');this.write(node.id);this.write(' = ');this.generateNode(node.init); } else if (kind === NN_FUNCTION) { this.write('function ');if (node.id) { this.write(node.id); } ;this.generateArguments(node.parameter);this.write(' { ');this.generateBody(node.body);this.write(' } '); } else if (kind === NN_CLASS) { this.write('let ');this.write(node.id);this.write(' = ');this.write('(function () { ');this.write('function ');this.write(node.id);if (node.ctor !== null) { this.generateArguments(node.ctor.init.parameter);this.write(' { ');this.generateBody(node.ctor.init.body);this.write(' } '); } else  { this.write('() { ');this.generateNodesOfBody(node.body, NN_CLASS_PROPERTY);this.write(' }; '); } ;this.generateNodesOfBody(node.body, NN_CLASS_METHOD);this.write('return (');this.write(node.id);this.write(');');this.write(' })() '); } else if (kind === NN_LET) { this.write('let ');this.write(node.id);this.write(' = ');this.generateNode(node.init); } else if (kind === NN_CONST) { this.write('const ');this.write(node.id);this.write(' = ');this.generateNode(node.init); } else if (kind === NN_EXPORT) { if (node.node.kind === NN_FUNCTION) { this.generateNode(node.node);this.write('module.exports.');this.write(node.node.id);this.write(' = ');this.write(node.node.id); } else if (node.node.kind === NN_LET||node.node.kind === NN_CONST) { this.write('module.exports.');this.write(node.node.id);this.write(' = ');this.generateNode(node.node.init); } else if (node.node.kind === NN_LITERAL) { this.write('module.exports.');this.write(node.node.value);this.write(' = ');this.generateNode(node.node); } else  { __imports.error('Cannot export '+node.node.kind); } ; } else if (kind === NN_IF) { if (node.condition) { this.write('if (');this.generateNode(node.condition);this.write(')'); } ;this.write(' { ');this.generateBody(node.consequent);this.write(' } ');if (node.alternate) { this.write('else ');this.generateNode(node.alternate); } ; } else if (kind === NN_RETURN) { this.write('return (');this.generateNode(node.argument);this.write(')'); } else if (kind === NN_WHILE) { this.write('while ');this.write('(');this.generateNode(node.condition);this.write(')');this.write(' {');this.generateBody(node.body);this.write(' } '); } else if (kind === NN_BREAK) { this.write('break');this.write(''); } else if (kind === NN_CONTINUE) { this.write('continue');this.write(''); } else if (kind === NN_CALL_EXPRESSION) { this.generateNode(node.callee);this.write('(');let ii = 0;while (ii<node.parameter.length) {this.generateNode(node.parameter[ii]);if (ii+1<node.parameter.length) { this.write(', '); } ;ii++; } ;this.write(')'); } else if (kind === NN_BINARY_EXPRESSION) { this.generateNode(node.left);if (node.operator === '==') { this.write(' === '); } else if (node.operator === '!=') { this.write(' !== '); } else  { this.write(node.operator); } ;this.generateNode(node.right); } else if (kind === NN_MEMBER_EXPRESSION) { this.generateNode(node.parent);this.write('.');this.generateNode(node.member); } else if (kind === NN_COMPUTED_MEMBER_EXPRESSION) { this.generateNode(node.parent);this.write('[');this.generateNode(node.member);this.write(']'); } else if (kind === NN_UNARY_PREFIX_EXPRESSION) { this.write(node.operator);if (node.operator === 'new') { this.write(' '); } ;this.generateNode(node.value); } else if (kind === NN_UNARY_POSTFIX_EXPRESSION) { this.generateNode(node.value);this.write(node.operator); } else if (kind === NN_OBJECT_EXPRESSION) { this.write('{');let ii = 0;while (ii<node.properties.length) {let property = node.properties[ii];this.generateNode(property.id);this.write(': ');this.generateNode(property.value);if (ii+1<node.properties.length) { this.write(', '); } ;ii++; } ;this.write(' }'); } else if (kind === NN_ARRAY_EXPRESSION) { this.write('[');let ii = 0;while (ii<node.elements.length) {let element = node.elements[ii];this.generateNode(element.value);if (ii+1<node.elements.length) { this.write(', '); } ;ii++; } ;this.write(']'); } else if (kind === NN_LITERAL) { this.write(node.value); } else if (kind === NN_STRING_LITERAL) { let isChar = node.isChar;if (isChar) { this.write('"'); } else  { this.write("'"); } ;this.write(node.value);if (isChar) { this.write('"'); } else  { this.write("'"); } ; } else if (kind === NN_INCLUDE) { this.write(node.code); } else  { __imports.error('Unknown node kind '+node.kind+'!'); } ; } ;return (Generator); })() ;;function inference(node) { console.log(node); } ;;function compile(str) { let base = '(function() { "use strict"; \n';let scanner = new Scanner();let tokens = scanner.scan(str);let parser = new Parser();let ast = parser.parse(tokens);let generator = new Generator();let code = generator.generate(ast);code=base+code+'\n})();';return ({output: code, errors: errors }); } module.exports.compile = compile;
})();